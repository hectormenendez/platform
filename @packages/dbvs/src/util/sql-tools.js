const { AGGREGATOR_PUSH, AGGREGATOR_QUEUE } = require("../config");

/** @enum {string} KWORD */
const KWORD = {
    PK: "PRIMARY KEY",
    NOTNULL: "NOT NULL",
    UNIQUE: "UNIQUE",
    CASCADE: "CASCADE",
    RESTRICT: "RESTRICT",
    GEN_DEFAULT: "GENERATED BY DEFAULT",
    GEN_ALWAYS: "GENERATED ALWAYS",
    ID_DEFAULT: "",
    ID_ALWAYS: "",
};

KWORD.ID_DEFAULT = `${KWORD.GEN_DEFAULT} AS IDENTITY`;
KWORD.ID_ALWAYS = `${KWORD.GEN_ALWAYS} AS IDENTITY`;

/** @enum {string} TYPE */
const TYPE = {
    INT: "INTEGER",
    INT_SMALL: "SMALLINT",
    INT_BIG: "BIGINT",
    TEXT: "TEXT",
};

/** @enum {string} OBJECT */
const OBJECT = {
    SCHEMA: "SCHEMA",
    TABLE: "TABLE",
    COLUMN: "COLUMN",
};

/** @enum {string} OBJECT */
const CHAR = {
    SQUOTE: `'`,
    DQUOTE: `"`,
    NEWLINE: "\\n",
};

const get = {
    /** @param {string|string[]} content */
    content(content) {
        if (typeof content !== "string" && !Array.isArray(content)) {
            throw new TypeError(
                `Expecting content to be a string, got: ${typeof content}`,
            );
        }
        let result = content;
        if (Array.isArray(result)) {
            result = result.filter(Boolean).join(" ");
        }
        return result.trim();
    },

    wrap({ content, wrapper }) {
        if (typeof wrapper !== "string" && !Array.isArray(wrapper)) {
            throw new TypeError(`Expecting a "wrapper" string or array, got: ${wrapper}`);
        }
        const char = Array.isArray(wrapper) ? wrapper.slice(0, 2) : [wrapper, wrapper];
        return [char[0], get.content(content), char[1]].join("");
    },

    safe({ safe = null, not = false }) {
        if (!safe) return "";
        return `IF ${(not && "NOT ") || ""}EXISTS`;
    },

    auth({ auth = null }) {
        if (!auth) return "";
        return `AUTHORIZATION ${auth}`;
    },

    name({ name, schema = null, quote = true }) {
        const q = (content) => {
            if (!quote) return content;
            return this.wrap({ content, wrapper: CHAR.DQUOTE });
        };
        return [!schema ? "" : `${q(schema)}.`, q(name)].join("");
    },

    kword({ kword = [], allowed = [] }) {
        if (kword && !Array.isArray(kword)) {
            throw new TypeError(`Expecting "kword" Array, got: ${kword}`);
        }
        if (!kword || !kword.length) return "";
        return kword
            .map((o) => {
                if (!allowed.includes(o)) {
                    throw new TypeError(`"${o}" is not allowed.`);
                }
                return o;
            })
            .join(" ");
    },
};

const Tools = (module.exports = {
    KWORD,
    TYPE,
    OBJECT,
    CHAR,

    SET: {
        NOW: () => "",
    },

    Schema: {
        /**
         * @param {Object} o
         * @param {string} o.name - The Schema name.
         * @param {boolean} [o.safe] - adds "IF EXISTS".
         * @param {KWORD[]} [o.set] - Allow manually setting keyords.
         */
        drop({ name, safe = null, set = null }) {
            const { CASCADE, RESTRICT } = KWORD;
            this[AGGREGATOR_PUSH]([
                `DROP ${OBJECT.SCHEMA}`,
                get.safe({ safe }),
                get.name({ name }),
                get.kword({ kword: set, allowed: [CASCADE, RESTRICT] }),
            ]);
        },

        /**
         * @param {Object} o
         * @param {string} o.name - The Schema name.
         * @param {boolean} [o.safe] - adds "IF NOT EXISTS".
         * @param {string} [o.auth] - Authorize user.
         */
        create({ name, safe = null, auth = null }) {
            this[AGGREGATOR_PUSH]([
                `CREATE ${OBJECT.SCHEMA}`,
                get.safe({ safe, not: true }),
                get.name({ name }),
                get.auth({ auth }),
            ]);
        },
    },

    Table: {
        /**
         * @param {Object} o
         * @param {string} o.name - The name of the table.
         * @param {string} [o.schema] - The schema the table belongs to.
         * @param {boolean} [o.safe] - adds "IF NOT EXISTS".
         * @param {KWORD[]} [o.set] - Allow manually setting keyords.
         */
        drop({ name, schema = null, safe = null, set = null }) {
            this[AGGREGATOR_PUSH]([
                `DROP ${OBJECT.TABLE}`,
                get.safe({ safe }),
                get.name({ name, schema }),
                get.kword({ kword: set, allowed: [KWORD.CASCADE, KWORD.RESTRICT] }),
            ]);
        },

        /**
         * @param {Object} o
         * @param {string} o.name - The name of the table.
         * @param {string} [o.schema] - The schema the table belongs to.
         * @param {boolean} [o.safe] - adds "IF NOT EXISTS".
         * @param {boolean} [o.temp] - adds "TEMPORARY".
         * @param {boolean} [o.log] - when falsy adds "UNLOGGED"
         * @param {function[]} [o.fields] - Adds fields specifications.kk
         */
        create(o) {
            const { name, schema = null, safe = null, temp = null, log = true } = o;
            let { fields } = o;
            if (fields) {
                fields = fields.map((field, i) => {
                    if (!field || typeof field !== "function") {
                        throw new TypeError(
                            `Expecting a function on field #${i}, got: ${typeof field}`,
                        );
                    }
                    return field({ name, schema });
                });
            }
            this[AGGREGATOR_PUSH]([
                "CREATE",
                temp && "TEMPORARY",
                !log && "UNLOGGED",
                OBJECT.TABLE,
                get.safe({ safe, not: true }),
                get.name({ name, schema }),
                fields && get.wrap({ content: fields.join(","), wrapper: ["(", ")"] }),
            ]);
        },
    },

    Comment: {
        field({ nameField, nameTable, schema, comment, aggregator = AGGREGATOR_PUSH }) {
            if (!Array.isArray(comment)) return;
            this[aggregator]([
                "COMMENT ON",
                OBJECT.COLUMN,
                get.name({
                    name: get.wrap({ content: nameField, wrapper: CHAR.DQUOTE }),
                    schema: get.name({ name: nameTable, schema }),
                    quote: false,
                }),
                "IS",
                `E'${comment.join(CHAR.NEWLINE)}'`,
            ]);
        },
    },

    Field: {
        /**
         * @param {Object} o
         * @param {string} [o.name] - The name of the field.
         * @param {TYPE} [o.type] - The type used for the id.
         * @param {KWORD[]} [o.set] - Allow manually set kwords.
         * @param {string[]} [o.comment] - Enqueues a comment for this column.
         */
        id(o) {
            const { ID_ALWAYS, ID_DEFAULT, PK } = KWORD;
            const {
                name: nameField = "id",
                type = TYPE.INT,
                set = [KWORD.ID_ALWAYS, KWORD.PK],
                comment = null,
            } = o;
            return ({ name: nameTable, schema }) => {
                this.Comment.field({
                    nameField,
                    nameTable,
                    schema,
                    comment,
                    aggregator: AGGREGATOR_QUEUE,
                });
                return get.content([
                    get.name({ name: nameField }),
                    get.kword({
                        kword: [type],
                        allowed: [TYPE.INT, TYPE.INT_BIG, TYPE.INT_SMALL],
                    }),
                    get.kword({
                        kword: set,
                        allowed: [ID_ALWAYS, ID_DEFAULT, PK],
                    }),
                ]);
            };
        },

        /**
         * @param {Object} o
         * @param {string} [o.name] - The name of the field.
         * @param {TYPE} [o.type] - The type used for the id.
         * @param {KWORD[]} [o.set] - Allow manually set kwords.
         * @param {string[]} [o.comment] - Enqueues a comment for this column.
         */
        text({ name: nameField, comment = null, set = null, check = null }) {
            return ({ name: nameTable, schema }) => {
                const { UNIQUE, NOTNULL, PK } = KWORD;
                this.Comment.field({
                    nameField,
                    nameTable,
                    schema,
                    comment,
                    aggregator: AGGREGATOR_QUEUE,
                });
                return get.content([
                    get.name({ name: nameField }),
                    TYPE.TEXT,
                    get.kword({
                        kword: set,
                        allowed: [UNIQUE, NOTNULL, PK],
                    }),
                ]);
            };
        },

        dateTime() {
            return () => "";
        },
    },

    Check: {
        charLen() {
            return () => "";
        },
    },
});

Object.defineProperty(Tools, "get", {
    enumerable: false,
    configurable: false,
    writable: false,
    value: get,
});
